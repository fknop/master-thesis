% !TEX root = ../thesis.tex

\documentclass[../thesis.tex]{subfiles}
 
\begin{document}

In this chapter, we describe our implementation for the models presented in \autoref{chapter:models}. 
We talk about the difficulties encountered while trying to transform the theoretical model to code. 
We will also discuss some differences between the models and the implementation and some trade-offs that were taken in order to 
have the most performant solver.

The implementation was done in Scala using 
\emph{OscaR} (\ref{subsection:oscar}) as CP solver and
\emph{Gurobi Optimizer} (\ref{subsection:gurobi}) as MIP solver. The general implementation 
tries to keep the same API (Application Programming Interface) for the CP and MIP solvers with the only changes being optional options 
that can be passed to it. 



\section{Input and output format}

For consistency, both solvers take the same input format and returns the same output format.
We created a JSON (JavaScript Object Notation) Schema \cite{json:schema} to formulate our problems and solution assignments.
Those schemas allow us to create a typed data structure for JSON objects. All the typing validation 
is handled by the JSON Schema library. A small example of JSON schema can be found in \autoref{json:example}. 
This example defines a client structure which takes a required string property called \textit{name}.

\begin{lstfloat}
\begin{lstlisting}[language=json,firstnumber=1,caption={JSON Schema example},captionpos=b,label={json:example}]
  "client": {
    "type": "object",
    "properties": {
      "name": {
        "type": "string"
      }
    },
    "required": ["name"]
  }
\end{lstlisting}
\end{lstfloat}

\section{Mixed Integer Programming solver}

We used the Java API \cite{gurobi:java} of the Gurobi Optimizer in Scala to create our implementation. 
The implementation did not change from the theoretical model presented in \autoref{section:mipmodel} as 
MIP solvers are less flexible in their modeling abilities than CP solvers as we discuss later. The Gurobi solver 
comes with default parameters \cite{gurobi:parameters}, it is advised to keep default parameters as 
changing them do not give much gain. Multiple different parameters were tested but as advised from the Gurobi website, 
no change were noticed.

\section{Constraint Programming solver}

The Constraint Programming implementation differ in some parts from the theoretical model 
presented in \autoref{section:cpmodel}. In Constraint Programming, the constraint propagation 
takes the most time in the solving algorithm. Propagations might be unecessary too strong for a model.
This is what happened with our model and the use of \texttt{softgcc} constraints. 

The minimization of fictitious workers described in (\ref{cp:fictitious}) used a \texttt{softgcc} in the model.
However, this constraint is slow to propagate in practice due to the high number of variables.
Using a CPU profiler, we noticed the \texttt{softgcc} constraint took up to 20\% of the solver runtime. 
OscaR proposes a variant of the \texttt{gcc} constraint which simply count the number of occurrences of values.


\begin{lstlisting}[style=scalaStyle,label={gcc_oscar},caption={Variant of \texttt{gcc} implemented in OscaR},captionpos=b]
gcc(x: Array[CPIntVar], o: Array[(Int, CPIntVar)])
\end{lstlisting}

This definition offers a weaker propagation for the variables but is enough for our model. 
This definition is used as follows:


\begin{lstlisting}[style=scalaStyle,label={gcc_oscar_2},caption={Usage of \texttt{gcc} to count fictitious workers},captionpos=b]
  // workerVariables: Array[CPIntVar]
  // sentinelViolations: CPIntVar
  // Constants.SentinelWorker: Int = -1
  add(
    gcc(workerVariables, Array(
        (Constants.SentinelWorker, sentinelViolations)
      )
    )
  )
\end{lstlisting}

We followed the same idea for the working requirements minimization (\ref{cp:wrequirements}). \texttt{softgcc} also turned out to be too strong.
We used a weaker model with the \texttt{gcc} described above and computed our own violations, similar to the \texttt{softgcc} definition,
from the occurrences given by the \texttt{gcc}.


\begin{lstlisting}[style=scalaStyle,label={gcc_oscar_2},caption={Usage of \texttt{gcc} to count working requirements violations},captionpos=b]
case class WorkingRequirement(worker: Int, min: Option[Int], max: Option[Int])

// ...

val violations: Array[CPIntVar] = Array.fill(requirements.length)(null)

val occurrences = requirements
  .map(_.worker)
  .map(w => (w, CPIntVar(0, workers(w).availabilities.size)))

add(gcc(workerVariables, occurrences))

// For each requirement 
for (i <- requirements.indices) {
  val r = requirements(i)
  violations(i) = maximum(Array(
      occurrences(i)._2 - r.max.getOrElse(workers(r.worker).availabilities.size),
      -occurrences(i)._2 + r.min.getOrElse(0),
      CPIntVar(Set(0))
    )
  )
}

// workingRequirementsViolations: CPIntVar
add(sum(violations, workingRequirementsViolations))
\end{lstlisting}
\end{document}

