% !TEX root = ../../thesis.tex

\documentclass[../../thesis.tex]{subfiles}
 
\begin{document}


\section{Constraint Programming Model}
\label{section:cpmodel}

The translation to the mathematical (MIP) model to the CP model is fairly
straightforward. Binary variables are translated to integer variables, each value representing
one resource (i.e. worker, zone or machines). 
For example, binary variables $w_{0jkl}, \dots, w_{njkl}$ are transformed to a single variable 
$w_{jkl} \in \{0, \dots, n\}$



\subsection{Variables}

First, we need to express the set of workers for each demand at each time period in which that demand occurs.

\begin{equation}
\begin{split}
    w_{ijk} \in W \label{cpworkervariable} \\
\end{split}
\end{equation}

(\ref{cpworkervariable}) is the worker working at time $i$ for demand $j$ at the $k^{\text{th}}$ position 
with $t_i \in T$, $d_i \in D$, $t_i \in d_j^T$ and $k \in d^P_j$. The same reasoning is used for zones and machines:

\begin{align}
    m_{ij} &\in M \label{cpmachinevariable} \\ 
    z_i &\in Z \label{cpzonevariable} 
\end{align}

(\ref{cpmachinevariable}) is the $j^{\text{th}}$ machine used for demand $i$ while (\ref{cpzonevariable}) is the zone used for demand $i$



As explained in the problem description and in the mathematical model section,
we need to allow partial solutions where we have a fictitious worker that can work at any time.
We will add this value to every worker variable domain but ignore it during the constraint propagation. We define 
this worker by $\sigma \notin W$. The actual value of this worker does not matter as long as it does not belong to $W$. For simplicity, we will define $\sigma = -1$.


Some constraints are already satisfied by the modeling of the variables, like the number of required resources (i.e. worker, location, machine)
per demand. We also satisfy the required skills and availabilities for each position by only initializing variables with the 
possible workers. Let $W_{d^{s_k}_j} \subseteq W$ be the subset of workers that satisfy the $k$th skill (set of skills) of demand $d_j$.

\begin{equation}
  w_{ijk} \in W_{d^{s_k}_j} \cap \{ w \mid t_i \in w^T \} \cap \{ \sigma \}, \forall j \in D, i \in d^T_j, k \in d^P_j
\end{equation}

Note that initializing the variables with a reduced set of values is semantically equivalent to adding a \texttt{not\_equal} constraint for each impossible value.

\subsection{Constraints}

\subsubsection{All workers for one period must be different}

All the worker variables for a given time period must be different. 
The \texttt{alldifferent} (\autoref{sota:alldifferent}) constraint is well suited to express this. 
However, as our model has the fictitious worker $\sigma$ in the domain of all worker variables and this value 
can appear as many times as possible, we will need a slight variant of the \texttt{alldifferent} called \texttt{alldifferent\_except}. 
This constraint is the same as the original except that we can specify values that will be ignored from 
the constraint.

\begin{align*}
   \texttt{alldifferent\_except} (X, v) = \{& (d_1, \dots, d_n) \mid d_i \in D(x_i), \\ 
   & d_i \notin v \ \land \ d_j \ \notin v \implies d_i \neq d_j \ \forall i \neq j \}
\end{align*}

We will use this constraint to ignore the $\sigma$ value from the propagation. Let $X_i = \{w_{ijk} \mid j \in D, k \in d_j^P \}$ be the set of all worker variables for period $i$. For each period, we define:

\begin{equation}
  \texttt{alldifferent\_except}(X_i, \{ \sigma \}), \forall i \in T
\end{equation}

\subsubsection{Incompatibilities between workers and clients}

A worker might have an incompatibility with a client or a set of clients. 
Clients are statically assigned to demands, we can solve this constraint by adding 
a series of \texttt{not\_equal} constraints for each incompatible worker - client pair.

\begin{equation}
  \texttt{not\_equal}(w_{ijk}, w), \forall (w, c) \in I_{wc}, \forall \ i, j, k
\end{equation}

\subsubsection{Incompatibilities between workers}

A worker might have an incompatibility with a worker or a set of workers. This constraint cannot be solved 
with a series of \texttt{not\_equal} like the worker - client incompatibilities. We will use a constraint 
called \texttt{negative\_table}. This constraint is a type of \emph{Table Constraints} \cite{Henteryck:Table} which in general can
express either the allowed or forbidden combinations of values. In this case, \texttt{negative\_table} expresses the forbidden combinations of values.
The forbidden combinations of values is expressed by the table $I_{ww}$. 
We will add a \texttt{negative\_table} constraint for each pair of workers for a demand at one given time. Let $P_{ij} = \{ (w_{ijk}, w_{ijl}) \mid k \in d_j^P, l \in d_j^P, k \neq l \}$ 
be the permutations of worker variables for demand $j$ at period $i$:

\begin{equation}
  \texttt{negative\_table}(x, y, I_{ww}),  \forall (x, y) \in P_{ij}
\end{equation}

\subsubsection{Additional skills must be satisfied}

A demand can have what we call \emph{additional skills}. Those skills can be 
satisfied by any of the workers in the demand. Unlike required skills by different workers,
we cannot pre-assign possible values to domain of variables. The worker can be assigned to any number of variables in the demand.
We will use the \texttt{gcc} constraint coupled with a \texttt{sum} constraint.
The \texttt{gcc} will act as a counter of occurrences for the workers that satisfy the skills,
the sum will state that at least one worker need to be assigned.

Let us define $o_{ijs}$ the occurrences of workers at time $i$ for demand $j$ in $W_s$ (the set of workers that satisfy skill $s$).

\begin{align}
  &\texttt{gcc}(\{ w_{ijk} \mid k \in d^P_j \}, o_{ijs}) \\ 
  &\texttt{sum}(o_{ijs}) \geq 1 \\
  \text{with} \quad & o_{ijs} \in \{ 0, 1 \} \\
  & \forall j \in D, s \in d^{S^{+}}, i \in d^T_j
\end{align}

This is a different syntax for \texttt{gcc} that we introduced before. This variant takes 
variables and assign the occurrences of values to them. In this case, the \texttt{gcc} will assign 
occurrences of $w \in W_s$ to $o_{ijs}$ and the \texttt{sum} constraint will ensure that 
these occurrences sum to at least one.

\subsubsection{Minimizing violations of working requirements}

A worker might have working requirements. He has to work a minimum (maximum) number of times, hence the total 
occurrences of this worker must be above (below) or equal the requirement. As a solution cannot always be 
achieved with these requirements, we use a soft constraint and minimize the number of violations. In this case,
we use the \texttt{softgcc} constraint introduced in \autoref{sota:gcc}. Let $X$ be the entire set of variables and 
$v_r$ the total number of violations.

\begin{equation}
  \texttt{softgcc}(X, [r_{1_{min}}, \dots, r_{n_{min}}], [r_{1_{max}}, \dots, r_{n_{max}}], v_{r}) \label{cp:wrequirements} 
\end{equation}

Note that from a model point of view, if a worker does not have any requirement, $r_{min}$ will be 0 and $r_{max}$ will be $|{r_w}^T| $ (i.e. the number of availabilities of that worker).

\subsubsection{Minimizing the number of fictitious worker}

A solution might not always be possible, leading to a partial solution containing fictitious workers.
We defined this fictitious worker by the value $\sigma$. This is again a case of soft constraint where 
we will use a \texttt{softgcc}. Let $v_{\sigma}$ be the total number of violations.


\begin{equation}
  \texttt{softgcc}(X, \sigma \rightarrow \sigma, [0], [0], v_{\sigma}) \label{cp:fictitious}
\end{equation}

This syntax is a little bit different than what was introduced before. We specify $\sigma \rightarrow \sigma$ to check only the occurrences of values 
in that range, hence only $\sigma$ in our case.


\subsubsection{Objective Function}

We already defined violations $v_r$ (\ref{cp:wrequirements}) and $v_{\sigma}$ (\ref{cp:fictitious}) as our working requirements and fictitious worker violations respectively.
We also need to define a final part of our objective function which is not a violation per se. Let $N_{jk}$ be the number 
of different workers working for demand $j$ at position $k$ throughout the periods $d_j^T$. We use a 
constraint called \texttt{at\_least\_nvalue} to count this number.
Let  $W_{jk} = \{ w_{ijk} \mid i \in d^T_j \}$ be the set of worker variables for demand $j$ at position $k$ accross all time periods of that demand:

\begin{equation}
  \texttt{at\_least\_nvalue}(W_{jk}, N_{jk}) \ \forall j \in D, k \in d^P_j
\end{equation}

We now have the number of different workers for each shift and we need to minimize the sum of all $N_{jk}$ to avoid perturbations.

The final objective will be a weighted-sum of all sub-objectives in the model. However, not all objectives are equal 
in values, some objectives need bigger penalties when violated. This is the case for $v_r$ and $v_{\sigma}$.
We define three penalties $\delta_0$, $\delta_1$ and $\delta_2$ which are associated with our three sub-objectives.
We define those penalties in (\ref{penalties:objective}).

\begin{equation}
  \text{min} \quad \delta_0 \big( \sum_{j \in D} \sum_{k \in D^P_j} N_{jk} \big) + \delta_1 v_r + \delta_2 v_{\sigma} \label{cp:objective}
\end{equation}

\begin{equation}
  \label{penalties:objective}
  \bm{\delta} = (\delta_0, \delta_1, \delta_2) = (1, 15, 100)
\end{equation}




\subsection{Search}

We define a heuristic that allows:
\begin{enumerate*}[label=(\roman*)]
  \item the fictitious worker to never be selected if there is another value available in the domain of the variable;
  \item the worker chosen for a variable is the most available for that demand but is also the less available for other demands.
\end{enumerate*}

\subsubsection{Variable Heuristic}

The variable heuristic used for the search is a first-fail heuristic. In other words, the heuristic 
will chose the variable will the smallest domain. This allows variable with only one value alongside the 
fictitious value $\sigma$ to always be selected first.

\subsubsection{Most Available Value Heuristic}

We define a value heuristic that we call the \emph{most available heuristic}. 
This heuristic consists of two value ordering.
\begin{enumerate}
  \item The first ordering orders the workers from most available to least available throughout the duration of the demand.
        This allows the search to select workers that are more likely to work for that demand throughout all periods.
  \item If workers have the same availabilities for a demand, they are ordering in respect to their remaining availabilities in other demands. This 
        second ordering is important for smaller demands, the search will choose workers that are less likely to be needed in other demands.
\end{enumerate}

It also never considers the fictitious worker $\sigma$ for the worker value as it is not even considered 
for most available worker. This value heuristic will in practice find solutions much quicker than a traditional \emph{min} value heuristic.

Let us take an example to show how this heuristic works in practice, let us define 
$w_1$, $w_2$ and $w_3$, three possible workers for two demands $d_1$ and $d_2$ that only need one worker each.
The availabilities are defined as
$w_1^T = \{ 0, 1, 2 \}$, $w_2^T = \{ 0, 2 \}$, $w_3^T = \{ 0, 1, 2, 3, 4\}$ and the demand occurrences as 
$d_1^T = \{ 0, 1, 2 \}$, $d_2^T = \{ 0, 1, 2, 3, 4 \}$. Intuitively, we can see that worker 
$w_3$ should be assigned to $d_2$ and $w_1$ should be assigned to $d_1$. This is what the heuristic tries to achieve, the ordering for each demand will be as follow:

\begin{align*}
  \texttt{mostavailable}(d_1) &= [w_1 = (3, 0), w_3 = (3, 2), w_2 = (2, 0)] \\ 
  \texttt{mostavailable}(d_2) &= [w_3 = (5, 0), w_3 = (3, 0), w_2 = (2, 0)] \\ 
\end{align*}

First we can see that $w_2$ will never be considered in this case as it is not available enough. For $d_1$, both $w_1$ and $w_3$ have the 3 availabilities. However, 
$w_3$ has two remaining availabilities. This heuristic guess that those two remaining availabilities could be used elsewhere. In this case, it is used on $d_2$ where $w_3$ has all his 5 availabilities.
The search will always consider $w_1$ first for $d_1$ and $w_3$ first for $d_2$.

\subsubsection{Dynamic Value Heuristic}

The \emph{most available} heuristic works fairly well in practice as seen in \autoref{chapter:experiments}. 
We can however improve it by making it more dynamic to the search. Instead of one static ordering at the start of the search,
we can reorder values at each value selection to select the best worker in the current search tree.

To achieve this, we need to store some state during the search that will backtrack automatically.

\begin{enumerate}
  \item $occ_{wdp}$: the number of times worker $w$ already works for position $p$ of demand $d$.
  \item $occ_{w}$: the number of times worker $w$ already works in any demands.
  \item $a_{w} \subseteq w^T$: the set of remaining availabilities of the worker.
\end{enumerate}

We now have three level of ordering in the heuristic:

\begin{enumerate}
  \item The first ordering is now the occurrences $occ_{wpd}$ from greatest to smallest values. We prioritize workers that already work for this demand for the longest time.
  \item The second ordering is the same as the first static ordering except we now take into account the 
        remaining availabilities of the worker $a_w$ to select the most available worker.
  \item The third ordering is the second static ordering except we also take into account the number of times the worker 
        is already assigned $occ_w$.
\end{enumerate}

% Let us take another example with three workers $w_1$, $w_2$ and $w_3$ and with two demands $d_1$ and $d_2$.

\subsubsection{Breaking symmetries}

It is fairly easy to see that our problem contains a lot of symmetries between different positions within the same demand. 
Two positions might require no skill and thus have the same possible workers. We want to avoid as much as possible to consider every permutations of those workers.
For this, we use the \texttt{lexleq} constraint \cite{Alan:Lex}. This constraints takes two vectors of variables $X$ and $Y$. It ensures that 
$x_i \leq y_i \ \forall i$. As we already have an \texttt{alldifferent} constraint applied, it ensures $x_i < y_i \ \forall i$.
Let $x_i \in X$ be a variable symmetric to $y_i \in Y$ where $x_i$ and $y_i$ are two variables from the same demand occuring at the same time period.


\begin{equation}
  \texttt{lexleq}(X, Y)
\end{equation}

As a simple example, let us define $x_1 = x_2 = \{ 1, 2, 3 \}$ with $x_1 < x_2$ for symmetry breaking. If 
$x_1$ is assigned the value $2$, we will ignore the permutation $x_1 = 2, x_2 = 1$ because it is symmetric to $x_1 = 1, x_2 = 2$. $x_2$ will be instead directly assigned to the value $3$ and thus reducing the search space.
\autoref{tree:symmetry} shows the search trees with and without symmetry breaking. We can see that the search tree with the \texttt{lexleq} constraint is reduced.

\forestset{qtree/.style={for tree={draw, parent anchor=south, 
           rounded corners,
           align=center, l sep=40pt, s sep=20pt}}}

\begin{figure}
  \begin{adjustbox}{valign=t, center}
  \begin{forest}, baseline, qtree
    % for tree={l sep=20pt}
    [{\footnotesize$x = \{1, 2, 3\}$\\\footnotesize$y = \{ 1, 2, 3 \}$}
      [{\footnotesize$x = 1$\\\footnotesize$y = \{ 2, 3 \}$}, edge label={node[midway,left] {$x=1$}} 
      [{\footnotesize$x = 1$\\\footnotesize$y = 2$}, edge label={node[midway,left] {$y=2$}} ]
      [{\footnotesize$x = 1$\\\footnotesize$y = 3$}, edge label={node[midway,right] {$y=3$}} ]
      ]
      [{\footnotesize$x = 2$\\\footnotesize$y = 3$}, edge label={node[midway,right] {$x\neq1$}} ]
    ]
  \end{forest}
  
  \begin{forest}, baseline, qtree
    % for tree={l sep=20pt}
    [{\footnotesize$x = \{1, 2, 3\}$\\\footnotesize$y = \{ 1, 2, 3 \}$}
      [{\footnotesize$x = \{1\}$\\\footnotesize$y = \{ 2, 3 \}$}, edge label={node[midway,left] {$x=1$}} 
        [{\footnotesize$x = 1$\\\footnotesize$y = 2$}, draw={blue}, edge label={node[midway,left] {$y=2$}} ]
        [{\footnotesize$x = 1$\\\footnotesize$y = 3$}, draw={red}, edge label={node[midway,right] {$y=3$}} ]
      ]
      [{\footnotesize$x = \{ 2, 3 \}$\\\footnotesize$y = \{ 1, 2, 3 \}$}, edge label={node[midway,right] {$x\neq1$}} 
        [{\footnotesize$x = 2$\\\footnotesize$y = \{ 1, 3 \}$}, edge label={node[midway,left] {$x = 2$}} 
          [{\footnotesize$x = 2$\\\footnotesize$y = 1$}, draw={blue}, edge label={node[midway,left] {$y=1$}} ]
          [{\footnotesize$x = 2$\\\footnotesize$y = 3$}, draw={green}, edge label={node[midway,right] {$y=3$}} ]
        ]
        [{\footnotesize$x = 3$\\\footnotesize$y = \{ 1, 2 \}$}, edge label={node[midway,right] {$x = 3$}} 
          [{\footnotesize$x = 3$\\\footnotesize$y = 1$}, draw={red}, edge label={node[midway,left] {$y=1$}} ]
          [{\footnotesize$x = 3$\\\footnotesize$y = 2$}, draw={green}, edge label={node[midway,right] {$y=2$}} ]
        ]  
      ]
    ]
  \end{forest}
  \end{adjustbox}
  \caption{Search tree with symmetry breaking (left) and without (right)}
  \label{tree:symmetry}
\end{figure}

\subsubsection{Large Neighorhood Search}

We use LNS to ensure that we explore as much of the search space as possible. 
We use the Propagation Guided Relaxation \cite{Propagation:LNS} to relax our best solutions.
We discuss and compare more relaxations options in a future chapter.

\subsubsection{Variable Objective LNS}

Our problem uses a multi-objective (\ref{cp:objective}) model. 
Let us define $o_1 = \text{min} \ v_{\sigma}$, $o_2 = {\text{min} \ v_r}$, $o_3 = {\text{min} \ \sum_{j \in D} \sum_{k \in D^P_j} N_{jk}}$
and $o_4$ is the original weighted sum described in (\ref{cp:objective}).


We wish to optimize sub-objectives $o_1$ and $o_2$ first to avoid partial solutions and unmet requirements respectively. 

\begin{enumerate}
  \item First set $o_1$ to \emph{Strong-Filtering} while others are set to \emph{No-Filtering}.
  \item Once optimized, set $o_2$ to \emph{Strong-Filtering}, $o_1$ to \emph{Weak-Filtering} and others to \emph{No-Filtering}.
  \item Once $o_2$ is optimized, keep it in \emph{Weak-Filtering} for the rest of the search and switch $o_3$ to \emph{Strong-Filtering}.
\end{enumerate}

$o_4$ is also kept in \emph{Strong-Filtering} mode for the entire duration of the search to avoid having a weaker model than the original weighted-sum.

\end{document}

