% !TEX root = ../../thesis.tex

\documentclass[../../thesis.tex]{subfiles}
 
\begin{document}


\section{Constraint Programming Model}

The translation to the mathematical (MIP) model to the CP model is fairly
straightforward. Binary variables are translated to integer variables, each value representing
one resource (i.e. worker, zone or machines). 
For example, binary variables $w_{0jkl}, \dots, w_{njkl}$ are transformed to a single variable 
$w_{jkl} \in \{0, \dots, n\}$



\subsection{Variables}

First, we need to express the set of workers for each demand at each time period in which that demand occurs.

\begin{equation}
\begin{split}
    w_{ijk} \in W \label{cpworkervariable} \\
\end{split}
\end{equation}

(\ref{cpworkervariable}) is the worker working at time $i$ for demand $j$ at the $k^{\text{th}}$ position 
with $t_i \in T$, $d_i \in D$, $t_i \in d_j^T$ and $k \in d^P_j$. The same reasoning is used for zones and machines:

\begin{align}
    m_{ij} &\in M \label{cpmachinevariable} \\ 
    z_i &\in Z \label{cpzonevariable} 
\end{align}

(\ref{cpmachinevariable}) is the $j^{\text{th}}$ machine used for demand $i$ while (\ref{cpzonevariable}) is the zone used for demand $i$



As explained in the problem description and in the mathematical model section. 
We need to allow partial solutions where we have a fictitious worker that can work at any time.
We will add this value to every worker variable domain but ignore it during the constraint propagation. We define 
this worker by $\sigma \notin W$. The actual value of this worker does not matter as long as it does not belong to $W$. For simplicity, we will define $\sigma = -1$.


Some constraints are already satisfied by the modeling of the variables, like the number of required resources (i.e. worker, location, machine)
per demand. We also satisfy the required skills and availabilities for each position by only initializing variables with the 
possible workers. Let $W_{d^{s_k}_j} \subseteq W$ be the subset of workers that satisfy skill (set of skills) $k$ of demand $d_j$.

\begin{equation}
  w_{ijk} \in W_{d^{s_k}_j} \cap \{ w \mid t_i \in w^T \} \cap \{ \sigma \}, \forall j \in D, i \in d^T_j, k \in d^P_j
\end{equation}

Note that initializing the variables with a reduced set of values is semantically equivalent to adding a \texttt{not\_equal} constraint for each impossible value.

\subsection{Constraints}

\subsubsection{All workers for one period must be different}

All the worker variables for a given time period must be different. 
The \texttt{alldifferent} (\autoref{sota:alldifferent}) constraint is well suited to express this. 
However, as our model has the fictitious worker $\sigma$ in the domain of all worker variables and this value 
can appear as many times as possible, we will need a slight variant of the \texttt{alldifferent} called \texttt{alldifferent\_except}. 
This constraint is the same as the original except that we can specify values that will be ignored from 
the constraint.

\begin{equation*}
   \texttt{alldifferent\_except} (X, v) = \{ (d_1, \dots, d_n) \mid d_i \in D(x_i), d_i \neq d_j \ \land \ d_i \notin v \ \land \ d_j \ \notin v \  \forall i \neq j \}
\end{equation*}

We will use this constraint to ignore the $\sigma$ value from the propagation. Let $X_i = \{w_{ijk} \mid j \in D, k \in d_j^P \}$ be the set of all worker variables for period $i$. For each period, we define:

\begin{equation}
  \texttt{alldifferent\_except}(X_i, \{ \sigma \}), \forall i \in T
\end{equation}

\subsubsection{Incompatibilities between workers and clients}

A worker might have an incompatibility with a client or a set of clients. 
Clients are statically assigned to demands, we can solve this constraint by adding 
a series of \texttt{not\_equal} constraints for each incompatible worker - client pair.

\begin{equation}
  \texttt{not\_equal}(w_{ijk}, w), \forall (w, c) \in I_{wc}, \forall \ i, j, k
\end{equation}

\subsubsection{Incompatibilities between workers}

A worker might have an incompatibility with a worker or a set of workers. This constraint cannot be solved 
with a series of \texttt{not\_equal} like the worker - client incompatibilities. We will use a constraint 
called \texttt{negative\_table}. This constraint is a type of \emph{Table Constraints} \cite{Henteryck:Table} which in general can
express either the allowed or forbidden combinations of values. In this case, \texttt{negative\_table} expresses the forbidden combinations of values.
The forbidden combinations of values is expressed by the table $I_{ww}$. 
We will add a \texttt{negative\_table} constraint for each pair of workers for a demand at one given time. Let $P_{ij} = \{ (w_{ijk}, w_{ijl}) \mid k \in d_j^P, l \in d_j^P, k \neq l \}$ 
be the permutations of worker variables for demand $j$ at period $i$:

\begin{equation}
  \texttt{negative\_table}(x, y, I_{ww}),  \forall (x, y) \in P_{ij}
\end{equation}

\subsubsection{Minimizing violations of working requirements}

A worker might have working requirements. He has to work a minimum (maximum) number of times, hence the total 
occurrences of this worker must be above (below) or equal the requirement. As a solution cannot always be 
achieved with these requirements, we use a soft constraint and minimize the number of violations. In this case,
we use the \texttt{softgcc} constraint introduced in \autoref{sota:gcc}. Let $X$ be the entire set of variables and 
$v_r$ the total number of violations.

\begin{equation}
  \texttt{softgcc}(X, [r_{1_{min}}, \dots, r_{n_{min}}], [r_{1_{max}}, \dots, r_{n_{max}}], v_{r}) 
\end{equation}

Note that from a model point of view, if a worker does not have any requirement, $r_{min}$ will be 0 and $r_{max}$ will be $|{r_w}^T| $ (i.e. the number of availabilities of that worker).

\subsubsection{Minimizing the number of fictitious worker}

A solution might not always be possible, leading to a partial solution containing fictitious workers.
We defined this fictitious worker by the value $\sigma$. This is again a case of soft constraint where 
we will use a \texttt{softgcc}. Let $v_{\sigma}$ be the total number of violations.


\begin{equation}
  \texttt{softgcc}(X, \sigma \rightarrow \sigma, [0], [0], v_{\sigma})
\end{equation}

This syntax is a little bit different than what was introduced before. We specify $\sigma \rightarrow \sigma$ to check only the occurrences of values 
in that range, hence only $\sigma$ in our case.


\subsubsection{Objective Function}

We already defined violations $v_r$ and $v_{\sigma}$ as our working requirements and fictitious worker violations.
We also need to define a final part of our objective function which is not a violation per se. Let $N_{jk}$ be the number 
of different workers working for demand $j$ at position $k$ throughout the periods $d_j^T$. We use a 
constraint called \texttt{at\_least\_nvalue} to count this number.
Let  $W_{jk} = \{ w_{ijk} \mid i \in d^T_j \}$ be the set of worker variables for demand $j$ at position $k$ accross all time periods of that demand:

\begin{equation}
  \texttt{at\_least\_nvalue}(W_{jk}, N_{jk}) \ \forall j \in D, k \in d^P_j
\end{equation}

We now have the number of different workers for each shift and we need to minimize the sum of all $N_{jk}$ to avoid perturbations.
The final objective is:

\begin{equation}
  \text{min} \quad \big( \sum_{j \in D} \sum_{k \in D^P_j} N_{jk} \big) + v_r + v_{\sigma}
\end{equation}
% \subsubsection{Additional skill requirement}

% Additionnal skills are the skills that can be satisfied by any worker in the group.
% TODO: explain gcc + sum occurences

% \subsubsection{No zone should be used by two overlapping demands}

% Let $Z^O_i = \{ z_j \mid j \in d^O_i \}$ be the set of zone variables for demands that overlap in time with demand $i$.
% The constraint $\texttt{allDifferent}(Z^O_i)$ states that all zones for overlapping demands 
% should be different. For each demand $i$ and set $Z^O_i$, we add an \texttt{allDifferent} constraint.

% \subsubsection{No machine should be used by two overlapping demands}

% Let $M^O_i = \left\{ m_{jk} \mid j \in d^O_i, k \in \{0, \dots, |d^M_j| - 1 \} \right\}$ be the set of machine variables for demands that overlap in time 
% with demand $i$. The constraint $\texttt{allDifferent}(M^O_i)$ states that all machines for overlapping demands 
% should be different. For each demand $i$ and set $M^O_i$, we add an \texttt{allDifferent} constraint.

% \subsubsection{Objective function}

% The objective function expresses the minimization of the sum of different worker for each shift.
% Let $W_{jk} = \{ w_{ijk} \mid i \in d^T_j \}$ be the set of all worker variables for demand $j$ at position $k$ accross all time periods for that demand.
% We use this set to compute the number of different workers for a given shift with the constraint
% $\texttt{atLeastNValue}(W_{jk}, N_{jk})$ with $N_{jk}$ being the number of different workers for shift $k$ of demand $j$.
% The objective can be expressed by $\sum_{j, k} N_{jk}$ which is the sum of different workers over all shifts. 



\subsection{Complete Model}

For this model, we define additional notations:

\begin{itemize}
  \item[--] $N_{jk}$ denotes the number of different workers for shift $k$ of demand $j$, these are variables added separete to the decision variables.
  \item[--] $W_{jk} = \{ w_{ijk} \mid i \in d^T_j \}$ denotes the set of worker variables for demand $j$ at position $k$ accross all time periods of that demand.
  \item[--] $X_i = \{w_{ijk} \mid j \in D, k \in d_j^P \}$ denotes the set of worker variables for all the demands accross time period $t_i$
  \item[--] $Z^O_i = \{ z_{j} \mid j \in d^O_i \}$ denotes the set of zone variables for demands that overlap in time with $d_i$
  \item[--] $M^O_i = \left\{ m_{jk} \mid j \in d^O_i, k \in \{0, \dots, |d^M_j| - 1 \} \right\}$ denotes the set of machine variables for demands that overlap in time with $d_i$ 
  \item[--] $P_{ij}$ denotes the set of permutations of pairs of worker variables for a demand $j$ at time $i$.
\end{itemize}

\begin{align}
  \textrm{min} \quad & \sum_{j \in D} \sum_{k \in D^P_j} N_{jk} & \label{cpobj} \\ 
  \textrm{s.t} \quad & \texttt{atLeastNValue}(W_{jk}, N_{jk}), && \forall j \in D, k \in d^P_j \label{cpobjctr} \\
                     & \texttt{allDifferentExcept}(X_i, \{ \sigma \}), && \forall i \in T \label{cpw1} \\
                     & \texttt{softGcc}(X, \sigma \rightarrow \sigma, 0, 0, v_{\sigma}) && \\
                     & \texttt{softGcc}(X, 0 \rightarrow |W| -1, r_{min}, r_{max}, v_{r}) &&\\
                    %  & \texttt{lexLeq}()                            , && \forall j \in D, i \in d^T_j, (a, b) \in P_{ij} \\
                     & \texttt{allDifferent}(Z^O_i), && \forall i \in D \label{cpz1} \\
                     & \texttt{allDifferent}(M^O_i), && \forall i \in D \label{cpm1} \\ 
                     & \texttt{notEqual}(w_{ijk}, w), && \forall (w, c) \in I_{wc}, \label{cpw2} \\ 
                     & && i \in T, j \in D_c, k \in d^P_j \nonumber \\ 
                     & \texttt{negativeTable}(a, b, I_{ww}), && \forall (a, b) \in P_{ij} \label{cpw3} \\ 
                     & w_{ijk} \in W_{d^{s_k}_j} \cap \{ w \mid t_i \in w^T \} \cap \{ \sigma \}, && \forall j \in D, i \in d^T_j, k \in d^P_j \label{cpvw} \\ 
                     & z_{i} \in d_i^Z, && \forall i \in D \label{cpvz} \\ 
                     & m_{ij} \in \{ m \mid m \in W \land m = d^{M_j}_i \}, && \forall i \in D, j \in d^M_i \label{cpvm}
\end{align}


This model is simpler than the mathematical one described \autoref{section:mipmodel}. It 
needs less constraints to express the same problem. For example, (\ref{cpvw}) expresses multiple constraints (i.e. workers are restricted to positions with respect to their skills and to their availabilities)
in only one step which is the initialization of the variable. Hence, no constraints will run during the solving process. (\ref{cpvw}) also states that we add a 
fictitious worker $\sigma \notin W$ to every worker variables.

(\ref{cpvz}) expresses that the domain of zone variables are limited to the possible zones of a demand and (\ref{cpvm}) states that 
the domain of each machine variables for a demand are limited to the possible machines for that need.

(\ref{cpw1}) states that no workers should work for two positions at the same time. Constraint (\ref{cpw2}) states
the incompatibilities between clients and workers and restricts workers to work for incompatible clients while 
(\ref{cpw3}) prevent incompatible workers to work together.

Constraint (\ref{cpz1}) and (\ref{cpm1}) state that no zones and machines should be used for two overlapping demands.

Finally, for the objective, constraint (\ref{cpobjctr}) states that $N_{jk}$ will be equal to the number of different workers for the same position 
throughout time periods. The objective itself (\ref{cpobj}) is the minimization of the sum of all $N_{jk}$, hence minimizing the number of change between 
shifts.


\subsection{Search}

We define a heuristic that allows:
\begin{enumerate*}[label=(\roman*)]
  \item the fictitious worker to never be selected if there is another value available in the domain of the variable;
  \item the worker chosen for a variable is the most available for that demand but is also the less available for other demands.
\end{enumerate*}

\subsubsection{Variable Heuristic}

The variable heuristic used for the search is a first-fail heuristic. In other words, the heuristic 
will chose the variable will the smallest domain. This allows variable with only one value alongside the 
fictitious value $\sigma$ to always be selected first.

\subsubsection{Value Heuristic}

We define a value heuristic that we call the \emph{most available heuristic}. 
This heuristic consists of two value ordering.
\begin{enumerate}
  \item The first ordering orders the workers from most available to least available throughout the duration of the demand.
        This allows the search to select workers that are more likely to work for that demand throughout all periods.
  \item If workers have the same availabilities for a demand, they are ordering in respect to their remaining availabilities in other demands. This 
        second ordering is important for smaller demands, the search will choose workers that are less likely to be needed in other demands.
\end{enumerate}

It also never considers the fictitious worker $\sigma$ for the worker value as it is not even considered 
for most available worker.

This value heuristic will in practice find solutions much quicker than a traditional \emph{min} value heuristic.

\end{document}

